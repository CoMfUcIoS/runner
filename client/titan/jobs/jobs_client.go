package jobs

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-swagger/go-swagger/client"

	strfmt "github.com/go-swagger/go-swagger/strfmt"
)

// New creates a new jobs API client.
func New(transport client.Transport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for jobs API
*/
type Client struct {
	transport client.Transport
	formats   strfmt.Registry
}

/*
DeleteGroupsGroupNameJobsID deletes the job

Delete only succeeds if job status is one of `succeeded
| failed | cancelled`. Cancel a job if it is another state and needs to
be deleted.  All information about the job, including the log, is
irretrievably lost when this is invoked.

*/
func (a *Client) DeleteGroupsGroupNameJobsID(params *DeleteGroupsGroupNameJobsIDParams) (*DeleteGroupsGroupNameJobsIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteGroupsGroupNameJobsIDParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "DeleteGroupsGroupNameJobsID",
		Method:             "DELETE",
		PathPattern:        "/groups/{group_name}/jobs/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteGroupsGroupNameJobsIDReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteGroupsGroupNameJobsIDOK), nil
}

/*
GetGroupsGroupNameJobs gets job list by group name

This will list jobs for a particular group.
*/
func (a *Client) GetGroupsGroupNameJobs(params *GetGroupsGroupNameJobsParams) (*GetGroupsGroupNameJobsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGroupsGroupNameJobsParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "GetGroupsGroupNameJobs",
		Method:             "GET",
		PathPattern:        "/groups/{group_name}/jobs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetGroupsGroupNameJobsReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetGroupsGroupNameJobsOK), nil
}

/*
GetGroupsGroupNameJobsID gets job by id

Gets a job by id.
*/
func (a *Client) GetGroupsGroupNameJobsID(params *GetGroupsGroupNameJobsIDParams) (*GetGroupsGroupNameJobsIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGroupsGroupNameJobsIDParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "GetGroupsGroupNameJobsID",
		Method:             "GET",
		PathPattern:        "/groups/{group_name}/jobs/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetGroupsGroupNameJobsIDReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetGroupsGroupNameJobsIDOK), nil
}

/*
GetGroupsGroupNameJobsIDLog gets the log of a completed job

Retrieves the log from log storage.
*/
func (a *Client) GetGroupsGroupNameJobsIDLog(params *GetGroupsGroupNameJobsIDLogParams) (*GetGroupsGroupNameJobsIDLogOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGroupsGroupNameJobsIDLogParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "GetGroupsGroupNameJobsIDLog",
		Method:             "GET",
		PathPattern:        "/groups/{group_name}/jobs/{id}/log",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetGroupsGroupNameJobsIDLogReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetGroupsGroupNameJobsIDLogOK), nil
}

/*
GetJobs gets next job

Gets the next job in the queue, ready for processing. Titan may return <=n jobs. Consumers should start processing jobs in order. Each returned job is set to `status` "running" and `started_at` is set to the current time. No other consumer can retrieve this job.
*/
func (a *Client) GetJobs(params *GetJobsParams) (*GetJobsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetJobsParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "GetJobs",
		Method:             "GET",
		PathPattern:        "/jobs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetJobsReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetJobsOK), nil
}

/*
PatchGroupsGroupNameJobsID ds e p r e c a t e d update a job

Used to update status on job transitions. Eg: from 'running' to 'success'.
*/
func (a *Client) PatchGroupsGroupNameJobsID(params *PatchGroupsGroupNameJobsIDParams) (*PatchGroupsGroupNameJobsIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPatchGroupsGroupNameJobsIDParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "PatchGroupsGroupNameJobsID",
		Method:             "PATCH",
		PathPattern:        "/groups/{group_name}/jobs/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PatchGroupsGroupNameJobsIDReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PatchGroupsGroupNameJobsIDOK), nil
}

/*
PostGroupsGroupNameJobs enqueues job

Enqueues job(s). If any of the jobs is invalid, none of the jobs are enqueued.

*/
func (a *Client) PostGroupsGroupNameJobs(params *PostGroupsGroupNameJobsParams) (*PostGroupsGroupNameJobsCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostGroupsGroupNameJobsParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "PostGroupsGroupNameJobs",
		Method:             "POST",
		PathPattern:        "/groups/{group_name}/jobs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostGroupsGroupNameJobsReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostGroupsGroupNameJobsCreated), nil
}

/*
PostGroupsGroupNameJobsIDCancel cancels a job

Cancels a job in delayed, queued or running status. The worker may continue to run a running job. reason is set to `client_request`.
*/
func (a *Client) PostGroupsGroupNameJobsIDCancel(params *PostGroupsGroupNameJobsIDCancelParams) (*PostGroupsGroupNameJobsIDCancelOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostGroupsGroupNameJobsIDCancelParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "PostGroupsGroupNameJobsIDCancel",
		Method:             "POST",
		PathPattern:        "/groups/{group_name}/jobs/{id}/cancel",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostGroupsGroupNameJobsIDCancelReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostGroupsGroupNameJobsIDCancelOK), nil
}

/*
PostGroupsGroupNameJobsIDError marks job as failed

Job is marked as failed if it was in a valid state. Job's `finished_at` time is initialized.
*/
func (a *Client) PostGroupsGroupNameJobsIDError(params *PostGroupsGroupNameJobsIDErrorParams) (*PostGroupsGroupNameJobsIDErrorOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostGroupsGroupNameJobsIDErrorParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "PostGroupsGroupNameJobsIDError",
		Method:             "POST",
		PathPattern:        "/groups/{group_name}/jobs/{id}/error",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostGroupsGroupNameJobsIDErrorReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostGroupsGroupNameJobsIDErrorOK), nil
}

/*
PostGroupsGroupNameJobsIDLog sends in a log for storage

Logs are sent after a job completes since they may be very large and the runner can process the next job.
*/
func (a *Client) PostGroupsGroupNameJobsIDLog(params *PostGroupsGroupNameJobsIDLogParams) (*PostGroupsGroupNameJobsIDLogCreated, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostGroupsGroupNameJobsIDLogParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "PostGroupsGroupNameJobsIDLog",
		Method:             "POST",
		PathPattern:        "/groups/{group_name}/jobs/{id}/log",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"multipart/form-data"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostGroupsGroupNameJobsIDLogReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostGroupsGroupNameJobsIDLogCreated), nil
}

/*
PostGroupsGroupNameJobsIDRetry retries a job

"The /retry endpoint can be used to force a retry of jobs
with status succeeded or cancelled. It can also be used to retry jobs
that in the failed state, but whose max_retries field is 0. The retried
job will continue to have max_retries = 0."

*/
func (a *Client) PostGroupsGroupNameJobsIDRetry(params *PostGroupsGroupNameJobsIDRetryParams) (*PostGroupsGroupNameJobsIDRetryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostGroupsGroupNameJobsIDRetryParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "PostGroupsGroupNameJobsIDRetry",
		Method:             "POST",
		PathPattern:        "/groups/{group_name}/jobs/{id}/retry",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostGroupsGroupNameJobsIDRetryReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostGroupsGroupNameJobsIDRetryOK), nil
}

/*
PostGroupsGroupNameJobsIDStart marks job as started ie status running

Job status is changed to 'running' if it was in a valid state before. Job's `started_at` time is initialized.
*/
func (a *Client) PostGroupsGroupNameJobsIDStart(params *PostGroupsGroupNameJobsIDStartParams) (*PostGroupsGroupNameJobsIDStartOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostGroupsGroupNameJobsIDStartParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "PostGroupsGroupNameJobsIDStart",
		Method:             "POST",
		PathPattern:        "/groups/{group_name}/jobs/{id}/start",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostGroupsGroupNameJobsIDStartReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostGroupsGroupNameJobsIDStartOK), nil
}

/*
PostGroupsGroupNameJobsIDSuccess marks job as succeeded

Job status is changed to succeeded if it was in a valid state before. Job's `completed_at` time is initialized.
*/
func (a *Client) PostGroupsGroupNameJobsIDSuccess(params *PostGroupsGroupNameJobsIDSuccessParams) (*PostGroupsGroupNameJobsIDSuccessOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostGroupsGroupNameJobsIDSuccessParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "PostGroupsGroupNameJobsIDSuccess",
		Method:             "POST",
		PathPattern:        "/groups/{group_name}/jobs/{id}/success",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostGroupsGroupNameJobsIDSuccessReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostGroupsGroupNameJobsIDSuccessOK), nil
}

/*
PostGroupsGroupNameJobsIDTouch extends job timeout

Consumers can sometimes take a while to run the task after accepting it.  An example is when the runner does not have the docker image locally, it can spend a significant time downloading the image.
If the timeout is small, the job may never get to run, or run but not be accepted by Titan. Consumers can touch the job before it times out. Titan will reset the timeout, giving the consumer another timeout seconds to run the job.
Touch is only valid while the job is in a running state. If touch fails, the runner may stop running the job.

*/
func (a *Client) PostGroupsGroupNameJobsIDTouch(params *PostGroupsGroupNameJobsIDTouchParams) (*PostGroupsGroupNameJobsIDTouchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostGroupsGroupNameJobsIDTouchParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "PostGroupsGroupNameJobsIDTouch",
		Method:             "POST",
		PathPattern:        "/groups/{group_name}/jobs/{id}/touch",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostGroupsGroupNameJobsIDTouchReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostGroupsGroupNameJobsIDTouchOK), nil
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport client.Transport) {
	a.transport = transport
}
